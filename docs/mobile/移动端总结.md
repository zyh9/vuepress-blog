---
title: 移动端总结
sidebar: true
date: 2019-03-20
tags:
  - mobile
---

:::tip
总结移动端遇到的一些问题...
:::

<!-- more -->

## 移动端事件

		手指按下：
			ontouchstart
			
		手指移动：
			ontouchmove
			
		手指抬起：
			ontouchend
			
		注意：
			在移动端开发的时候，浏览器的模拟器时好时坏，
			一般不用on的方式绑定事件函数，要用事件绑定的方式(addEventListener)
		
		移动端click屏幕产生200-300ms的延迟响应
		
			移动设备上的web网页是有300ms延迟的，往往会造成按钮点击延迟甚至是点击失效。
		
		以下是历史原因：
		
			2007年苹果发布首款iphone上IOS系统搭载的safari为了将适用于PC端上大屏幕的网页能比较好的展示在手机端上，
			使用了双击缩放(double tap to zoom)的方案，比如你在手机上用浏览器打开一个PC上的网页，
			你可能在看到页面内容虽然可以撑满整个屏幕，但是字体、图片都很小看不清，此时可以快速双击屏幕上的某一部分，
			你就能看清该部分放大后的内容，再次双击后能回到原始状态。
			
			双击缩放是指用手指在屏幕上快速点击两次，iOS自带的 Safari浏览器会将网页缩放至原始比例。
			
			原因就出在浏览器需要如何判断快速点击上，当用户在屏幕上单击某一个元素时候，例如跳转链接<a href="#"></a>，
			此处浏览器会先捕获该次单击，但浏览器不能决定用户是单纯要点击链接还是要双击该部分区域进行缩放操作，
			所以，捕获第一次单击后，浏览器会先Hold一段时间t，如果在t时间区间里用户未进行下一次点击，
			则浏览器会做单击跳转链接的处理，如果t时间里用户进行了第二次单击操作，则浏览器会禁止跳转，
			转而进行对该部分区域页面的缩放操作。那么这个时间区间t有多少呢？在IOS safari下，大概为300毫秒。
			这就是延迟的由来。造成的后果用户纯粹单击页面，页面需要过一段时间才响应，给用户慢体验感觉，
			对于web开发者来说是，页面js捕获click事件的回调函数处理，需要300ms后才生效，也就间接导致影响其他业务逻辑的处理。

## 触摸事件的响应顺序

		1、ontouchstart 
		2、ontouchmove 
		3、ontouchend 
		4、onclick
		
		解决300ms延迟的问题，也可以通过绑定ontouchstart事件，加快对事件的响应

## 移动端的点透

		当上层元素发生点击的时候，下层元素也有点击（焦点）特性，
		在300ms之后，如果上层元素消失或者隐藏，目标点就会“漂移”到下层元素身上，就会触发点击行为。
			
		解决：
		
			1.下层不要使用有点击（焦点）特性的元素
			
			2.阻止pc事件

## 移动端阻止PC事件优点

		document.addEventListener('touchstart',function(ev){
			ev.preventDefault();
		});
		
		
		1.IOS10下设置meta禁止用户缩放是不可行的。（使用阻止pc事件就可以在IOS10下禁止用户缩放）
			
		2.解决IOS10下溢出隐藏的问题。
		
		3.禁止系统默认的滚动条、阻止橡皮筋效果
		
		4.禁止长按选中文字、选中图片、系统默认菜单
		
		5.解决点透问题
		
		6.也阻止了焦点元素的焦点行为(要正常使用：ev.stopPropagation()阻止冒泡)

## 移动端事件对象

		当给某个元素加上了事件绑定函数之后，事件函数默认的第一个参数就是事件对象
		
		事件对象：
			当用户在浏览器下触发了某个行为，事件对象会记录用户操作时一些细节信息。
		
		touches 当前位于*屏幕*上的所有手指的一个列表
		
		targetTouches 位于当前DOM元素上的手指的一个列表
		
		changedTouches  涉及当前事件的手指的一个列表
		
		div.addEventListener('touchmove',start);
		function start(ev){
			//this.innerHTML = ev.touches.length;
			//this.innerHTML = ev.targetTouches.length;
			this.innerHTML = ev.changedTouches.length;
		}

## 移动端input无法获取焦点的问题

在移动端开发中，我们有时有针对性的写一些特殊的重置，比如：

		* {
			-webkit-touch-callout: none;
			//阻止长按图片之后呼出菜单提示复制的行为
			
			-webkit-text-size-adjust: none;
			//禁用Webkit内核浏览器的文字大小调整功能
			
			-webkit-tap-highlight-color: rgba(0, 0, 0, 0);
			//避免点击a标签或者注册了click事件的元素时产生高亮
			
			-webkit-user-select: none;
			//禁止用户进行复制、选择
		}
		
		其中，-webkit-user-select: none;会产生一些问题，这是webkit内核浏览器下的一个bug
		阻止了用户的选择内容行为，会导致一些“内容可编辑”标签无法正常使用，比如input、textarea
		
		如果网站不需要阻止用户的选择内容的行为就可以使用如下样式：
		
			* {
				-webkit-user-select: text;
				-user-select: text;
			}
			
			另一种方式：
			*: not(input, textarea) {
				-webkit-touch-callout: none;
				-webkit-user-select: none;
			}
			
		user-select可能会导致与contenteditable = "true"元素的问题，以便更好的使用，所以下面的CSS也要加上
		
			HTML5全局 contenteditable属性
				contenteditable 属性规定是否可编辑元素的内容
		
			[contenteditable="true"] , input, textarea {
				-webkit-user-select: auto !important;
				-khtml-user-select: auto !important;
				-moz-user-select: auto !important;
				-ms-user-select: auto !important;
				-o-user-select: auto !important;
				user-select: auto !important;
			}

## 表单输入框placeholder的颜色值

		input::-webkit-input-placeholder{color:#ccc;}
		input:focus::-webkit-input-placeholder{color:#ddd;}

## 模拟按钮hover效果

		直接在body上添加ontouchstart，同样可激活移动端css的active效果
		移动端触摸按钮的效果，可明示用户有些事情正要发生，是一个比较好体验，但是移动设备中并没有鼠标指针，
		使用css的hover并不能满足我们的需求，还好国外有个激活移动端css的active效果

> 第一种

```html
	<!DOCTYPE html>
	<html>
	<head>
	<meta charset="utf-8">
	<meta content="width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=no" name="viewport">
	<meta content="yes" name="apple-mobile-web-app-capable">
	<meta content="black" name="apple-mobile-web-app-status-bar-style">
	<meta content="telephone=no" name="format-detection">
	<meta content="email=no" name="format-detection">
	<style type="text/css">
		a{-webkit-tap-highlight-color: rgba(0,0,0,0);}
		.btn-blue{display:block;height:42px;line-height:42px;text-align:center;border-radius:4px;font-size:18px;color:#FFFFFF;background-color: #4185F3;}
		.btn-blue:active{background-color: #357AE8;}
	</style>
	</head>
	<body ontouchstart>
		<div class="btn-blue">按钮</div>
	</body>
	</html>
```

> 第二种

```html
	<!DOCTYPE html>
	<html>
	<head>
	<meta charset="utf-8">
	<meta content="width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=no" name="viewport">
	<meta content="yes" name="apple-mobile-web-app-capable">
	<meta content="black" name="apple-mobile-web-app-status-bar-style">
	<meta content="telephone=no" name="format-detection">
	<meta content="email=no" name="format-detection">
	<style type="text/css">
		a{-webkit-tap-highlight-color: rgba(0,0,0,0);}
		.btn-blue{display:block;height:42px;line-height:42px;text-align:center;border-radius:4px;font-size:18px;color:#FFFFFF;background-color: #4185F3;}
		.btn-blue:active{background-color: #357AE8;}
	</style>
	</head>
	<body>
		<div class="btn-blue">按钮</div>
	<script type="text/javascript">
	document.addEventListener("touchstart", function(){}, true)
	</script>
	</body>
	</html>
```

> 兼容性ios5+、部分android 4+、winphone 8

> 第三种

> 要做到全兼容的办法，可通过绑定ontouchstart和ontouchend来控制按钮的类名

```html
	<!DOCTYPE html>
	<html>
	<head>
	<meta charset="utf-8">
	<meta content="width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=no" name="viewport">
	<meta content="yes" name="apple-mobile-web-app-capable">
	<meta content="black" name="apple-mobile-web-app-status-bar-style">
	<meta content="telephone=no" name="format-detection">
	<meta content="email=no" name="format-detection">
	<style type="text/css">
		a{-webkit-tap-highlight-color: rgba(0,0,0,0);}
		.btn-blue{display:block;height:42px;line-height:42px;text-align:center;border-radius:4px;font-size:18px;color:#FFFFFF;background-color: #4185F3;}
		.btn-blue-on{background-color: #357AE8;}
	</style>
	</head>
	<body>
		<div class="btn-blue">按钮</div>
	<script type="text/javascript">
	var btnBlue = document.querySelector(".btn-blue");
	btnBlue.ontouchstart = function(){
		this.className = "btn-blue btn-blue-on"
	}
	btnBlue.ontouchend = function(){
		this.className = "btn-blue"
	}
	</script>
	</body>
	</html>
```

## 禁止ios长按时不触发系统的菜单，禁止ios&android长按时下载图片

		.css{-webkit-touch-callout: none}

## 禁止ios和android用户选中文字

		.css{-webkit-user-select:none}

## 打电话发短信写邮件

		打电话
		<a href="tel:10086">打电话给:10086</a>
		
		发短信
		<a href="sms:10086">发短信给:10086</a>
		
		写邮件
		<a href="mailto:zyh@qq.com">zyh@qq.com</a>

## 实现0.5px的线条

		网络上有很多方法，如设置viewport，box-shawdow，border-image，background-image，transform:scale等，
		本文只介绍一种觉得比较好用的方法，一来兼容性好，二来不依赖图片。
		
		transform:scale(x,y)
		
		通过css支持定义border或者height为.5px大的线条，在android设备中的无法显示出来，这里有个小技巧，
		设置线条为1px，然后通过transform:scale(x,y)来缩放线条为原来的一半，可显示0.5px的线条。

```html
	<!DOCTYPE html>
	<html>
		<head>
		<meta charset="utf-8">
		<meta content="width=device-width,initial-scale=1,maximum-scale=1.0,user-scalable=no" name="viewport">
		<meta content="yes" name="apple-mobile-web-app-capable">
		<meta content="black" name="apple-mobile-web-app-status-bar-style">
		<meta content="telephone=no" name="format-detection">
		<meta content="email=no" name="format-detection">
		<title>点5测试 - scale</title>
		<style type="text/css">
		.line {
		    height: 50px;
		    line-height: 50px;
		    background-color: #CCC;
		    border-bottom:1px solid red
		} 
		.scale {
		    position: relative;
		    height: 50px;
		    line-height: 50px;
		    background-color: #CCC
		}
		.scale:after {
		    position: absolute;
		    content: '';
		    width: 100%;
		    left: 0;
		    bottom: 0;
		    height: 1px;
		    background-color: red;
		    -webkit-transform: scale(1,.5);
		    transform: scale(1,.5);
		    -webkit-transform-origin: center bottom;
		    transform-origin: center bottom
		}
		</style>
		</head>
		<body>
			<div class="line">1px</div>
			<br/><br/>    
			<div class="scale">0.5px</div>
		</body>
	</html>
```

## 实现0.5px的圆角边框

		原理：先定义1px的圆角边框，然后拉伸内容的宽度和高度为父级的2倍(边框厚度不变)，
		然后再使用transform:scale(0.5)缩放为原来的0.5倍

```html
	<!DOCTYPE html>
	<html>
		<head>
		<meta charset="utf-8">
		<meta content="width=device-width,initial-scale=1,maximum-scale=1.0,user-scalable=no" name="viewport">
		<meta content="yes" name="apple-mobile-web-app-capable">
		<meta content="black" name="apple-mobile-web-app-status-bar-style">
		<meta content="telephone=no" name="format-detection">
		<meta content="email=no" name="format-detection">
		<title>点5测试 - border-radius</title>
		<style type="text/css">
		body{padding: 50px;-webkit-touch-callout:none;}
		[class*="btn"]{margin: 0 auto;}
		.btn-1 {
		    width: 200px;
		    height: 42px;
		    -webkit-border-radius: 5px;
		    border-radius: 5px;
		    text-align: center;
		    line-height: 42px;
		    background-color: #EDEDED;
		    border: 1px solid red;
		}
		.btn {
		    position: relative;
		    width: 200px;
		    height: 42px;
		    -webkit-border-radius: 5px;
		    border-radius: 5px;
		    text-align: center;
		    line-height: 42px;
		    background-color: #EDEDED;
		}
		.btn:before {
		    content: '';
		    position: absolute;
		    top: -50%;
		    bottom: -50%;
		    left: -50%;
		    right: -50%;
		    -webkit-transform: scale(0.5);
		    transform: scale(0.5);
		    border-style: solid;
		    border-width: 1px;
		    border-color: red;
		    -webkit-border-radius: 10px;
		    border-radius: 10px;
		}
		</style>
		</script>
		</head>
		<body>
			<div class="btn-1">1px border</div>
			<br/><br/>
			<div class="btn">.5px border</div>
		</body>
	</html>
```

## CSS实现隐藏滚动条同时又可以滚动

		移动端页面为了更接近原生的体验，是否可以隐藏滚动条，同时又保证页面可以滚动？
		
		使用 overflow:hidden 隐藏滚动条，但存在的问题是：页面或元素失去了滚动的特性。
		由于只需要兼容移动浏览器（Chrome 和 Safari），于是想到了自定义滚动条的伪对象选择器
		::-webkit-scrollbar。
		
		应用如下 CSS 可以隐藏滚动条：
			//.element就是指出现滚动条的元素
			.element::-webkit-scrollbar {display:none}
		
		如果要兼容PC其他浏览器（IE、Firefox等），国外一位才人John Kurlak也研究出了一种办法。
		在容器外面再嵌套一层 overflow:hidden内部内容再限制尺寸和外部嵌套层一样，就变相隐藏了。
		
		<div class="outer-container">
		    <div class="inner-container">
		        <div class="content">
		        	......
		        </div>
		    </div>
		</div>
		.outer-container,.content {
		    width: 200px; height: 200px;
		}
		.outer-container {
		    position: relative;
		    overflow: hidden;
		}
		.inner-container {
		    position: absolute; 
		    left: 0;
		    overflow-x: hidden;
		    overflow-y: scroll;
		}
		 
		 /* for Chrome */
		.inner-container::-webkit-scrollbar {
		    display: none;
		}

## Rem布局原理

		其实rem布局的本质是等比缩放，一般是基于宽度
		
		假设我们将屏幕宽度平均分成100份，每一份的宽度用x表示，x = 屏幕宽度 / 100，
		如果将x作为单位，x前面的数值就代表屏幕宽度的百分比
		
		p {width: 50x} /* 屏幕宽度的50% */
		
		如果想要页面元素随着屏幕宽度等比变化，我们需要上面的x单位，不幸的是css中并没有这样的单位，
		幸运的是在css中有rem，通过rem这个桥梁，可以实现神奇的x
		
		通过上面对rem的介绍，可以发现，如果子元素设置rem单位的属性，
		通过更改html元素的字体大小，就可以让子元素实际大小发生变化
		
		html {font-size: 16px}
		p {width: 2rem} /* 32px*/
		
		html {font-size: 32px}
		p {width: 2rem} /*64px*/
		
		如果让html元素字体的大小，等于屏幕宽度的1/100，那1rem和1x就等价了
		
		html {fons-size: width / 100}
		p {width: 50rem} /* 50rem = 50x = 屏幕宽度的50% */
		
		如何让html字体大小一直等于屏幕宽度的百分之一呢？ 可以通过js来设置，一般需要在页面dom ready、resize和屏幕旋转中设置
		
		document.documentElement.style.fontSize = document.documentElement.clientWidth / 100 + 'px';
		
		那么如何把UE图中的获取的像素单位的值，转换为已rem为单位的值呢？公式是元素宽度 / UE图宽度 * 100
		
		假设UE图尺寸是640px，UE图中的一个元素宽度是100px，根据公式100/640*100 = 15.625
		
		p {width: 15.625rem}

## 比Rem更好的方案

		上面提到想让页面元素随着页面宽度变化，需要一个新的单位x，x等于屏幕宽度的百分之一，css3带来了rem的同时，也带来了vw和vh
		
			vw —— 视口宽度的 1/100
			vh —— 视口高度的 1/100
			
		聪明的你也许一经发现，这不就是单位x吗，没错根据定义可以发现1vw=1x，有了vw我们完全可以绕过rem这个中介了，
		下面两种方案是等价的，可以看到vw比rem更简单
		
			/* rem方案 */
			html {fons-size: width / 100}
			p {width: 15.625rem}
			
			/* vw方案 */
			p {width: 15.625vw}
			vw还可以和rem方案结合，这样计算html字体大小就不需要用js了
			
			html {fons-size: 1vw} /* 1vw = width / 100 */
			p {width: 15.625rem}
			虽然vw各种优点，但是vw也有缺点，首先vw的兼容性不如rem好，使用之前要看下
		
		兼容性	IOS	安卓
		rem	4.1+	2.1+
		vw	6.1+	4.4+
		另外，在使用弹性布局时，一般会限制最大宽度，比如在pc端查看我们的页面，此时vw就无法力不从心了，
		因为除了width有max-width，其他单位都没有，而rem可以通过控制html根元素的font-size最大值，而轻松解决这个问题

## H5禁止手机虚拟键盘弹出

		在移动端，input会默认触发手机的虚拟键盘，如何阻止手机虚拟键盘弹起呢？
		目前我试过有两个方案，一个是给input添加readonly属性，
		另一个就是在input事件处理方法前面添加一句document.activeElement.blur()
		
		readonly
		
			使用readonly方式来阻止虚拟键盘弹出应该是最简单最优雅的方式了。
			readonly属性规定输入字段为只读。只读字段是不能修改的。
			不过，用户仍然可以使用 tab键切换到该字段，还可以选中或拷贝其文本。
			
			值得一提的是它的取值，只要声明了readonly属性，不管取什么值都可以，
			比如readonly=""、readonly="readonly"、readonly="abc"都是一样的
			
			优点：简单
			缺点：在iOS的Safari中无效（未做更多情况测试）
		
		document.activeElement.blur()
		
			这是个什么玩意儿？document.activeElement是一个Web API接口。
			MDN上的解释是：它返回当前页面中获得焦点的元素，也就是说，如果此时用户按下了键盘上某个键，
			会在该元素上触发键盘事件，该属性是只读的。
		
			document.activeElement属性始终会引用DOM中当前获得了焦点的元素。
			元素获得焦点的方式有用户输入(通常是按Tab键)、在代码中调用focus()方法和页面加载。
			
			它里面有很多方法，在浏览器控制台查看，可以看到有很多方法
			
			MDN上还展示了一个有意思的示例，看这里 http://jsfiddle.net/w9gFj/
			
			那么document.activeElement.blur()为什么可以阻止虚拟键盘弹出呢？
			原因是：当你点击input的时候，document.activeElement获得了DOM中被聚焦的元素，
			也就是你点击的input，而调用.blur()方法，blur我相信大家都知道吧，就是取消聚焦。
			获得被聚焦的元素然后强制blur以达到没有聚焦的样子
			
			优点：支持Android、iOS
			缺点：需要添加额外的JS代码
		
			这句代码加在什么地方？加入有如下HTML
			
				<div class="calendar">
				    <div>
				        <input type="text" id="datePicker" placeholder="点击选择日期"/>
				    </div>
				</div>
				
			那么这句JS加在事件处理方法中
		
				$("#datePicker").focus(function(){
				    document.activeElement.blur();
				});
				
		就现在来说，用document.activeElement.blur()确实是在绕弯子，直接使用readonly是最佳方案。
		但是document.activeElement很强大，可以做很多事。

## 只有一个头部和内容不确定的高度，怎样实现头部固定和内容滚动？

		只是头部绝对定位，内容区不使用绝对定位来解决
		
			body{
				height:100%;
				overflow:hidden;
			}
			header{
				position:absolute;
				top:0;
				left:0;
				right:0;
				height:80px;
			}
			content{
				padding:80px 0 20px;
				height:100%;
				overflow-x:hidden;
				overflow-y:scroll;
				box-sizing:border-box;
			}
			
		分析：
			
			body设置固定显示区域（类似划个固定的区域框选子元素），header可以用绝对定位，内容区高度是不确定的，
			所以用上padding来设置内容的显示区域（左右下padding可适当添加），但是给内容加上height:100%的同时，
			一定要加上box-sizing:border-box，要不然内容区的高度就不是100%了

## 多行文本溢出

		单行文本溢出，对title类的使用非常多，而多行文本类，在详情介绍则用的比较多。
		
		/*单行文本溢出*/
		.inaline{
			overflow: hidden;
			white-space: nowrap;
			text-overflow: ellipsis;
		}
		
		/*多行文本溢出*/
		.intwoline{
			display: -webkit-box !important;
			overflow: hidden;
			text-overflow: ellipsis;
			word-break: break-all;
			-webkit-box-orient:vertical;
			-webkit-line-clamp:4;
		}
		属性-webkit-line-clamp就可以控制几行溢出，4就是第四行进行截断加...

## 移动端遇上表单元素底部被顶起

		@media (max-height:400px){
			element{
				display: none;
			}
		}
		
		分辨率高度小于等于设置值的时候识别
		
		一般设置为400px，但也不排除有些键盘高低不一致的情况，可根据情况适当修改

## 当input遇见了全屏背景

		在移动端开发过程中，有极少数使用全屏背景的情况。当input遇见了全屏背景，一切便不再美好。
		
		解决办法：
		
			let viewH = document.documentElement.clientHeight;
			document.getElementsByTagName('html')[0].style.cssText += `height:${viewH}px`;
			document.body.style.cssText += `height:${viewH}px`;

> 补充可视区宽高小知识

		可视区宽度
		
			document.body.clientWidth
			document.documentElement.clientWidth
		
		可视区高度
		
			document.documentElement.clientHeight
		
		仔细一看可视区高度怎么和可视区宽度少了一个呢？
		
		其实不难理解，body本身块元素，宽度自然撑满可视区宽度
		
		而高度并非如此，body自身的高度则根据子元素的高度来撑
		
		所以document.body.clientHeight指的就是body自身的宽度

## 移动网页调试神器vConsole以及Eruda使用技巧

		做移动端Web开发的一大痛点就是，在真机运行下无法查看console.log日志和其他信息如网络请求、显示本地存储等信息
		
		如果网页是运行在手机浏览器中还算好，可以把网址在电脑上打开查看console信息
		
		但是如果是做APP的内嵌H5页面，那就只能靠开发阶段在浏览器模拟环境中尽量没有Bug
		
		但是，一旦H5上线后报错那就比较麻烦了，而且还依赖APP环境才能跑的网页，更加难以查找问题
		
		如果让移动端也拥有类似Chrome DevTools工具那岂不是很愉快么？
		
		vConsole便是这样一款很棒的移动端DevTools工具，由大厂企鹅出品。

[vConsole github地址](https://github.com/Tencent/vConsole)

> Eruda

		Eruda是谁？
		
		Eruda 是一个专为手机网页前端设计的调试面板，类似 DevTools 的迷你版
		
		其主要功能包括：
		
		捕获 console 日志、检查元素状态、显示性能指标、捕获XHR请求、显示本地存储和 Cookie 信息、浏览器特性检测等等。

[集颜值技能于一身的Erdua](https://github.com/liriliri/eruda)

[使用技巧](https://github.com/liriliri/eruda/blob/master/doc/README_CN.md)

> Erdua的基本使用方法推荐使用CDN和可配置参数的形式，在页面引入如下代码：

```javascript
	;(function () {
	    var src = '//cdn.bootcss.com/eruda/1.2.4/eruda.min.js';
	    if (!/eruda=true/.test(window.location) && localStorage.getItem('active-eruda') !== 'true') return;
	    document.write('<scr' + 'ipt src="' + src + '"></scr' + 'ipt>');
	    document.write('<scr' + 'ipt>eruda.init();</scr' + 'ipt>');
	})();
	eruda.init();//里面可以传入要初始化哪些面板，默认加载所有
```

		这样使用方式没有错，但是如果Eruda要跟着发布到线上的话，那我们要删除这段代码？
		
		因为这样会不管你需不需要调试Eruda都会立即加载，在页面出现Eruda的图标
		
		我的目标是，Eruda可以保留在页面里，无论什么环境，只要我们想呼唤它出现的时候它才出现
		
		不需要它的时候它只是一段不会生效的普通代码


> 办法

		首先把上述引入代码的src放到if里，同时把localStorage改为sessionStorage
		
		active-eruda参数也可以改个更短的名字，改后的代码如下：

```javascript
	;(function () {
	    if (!/eruda=true/.test(window.location) || sessionStorage.getItem('eruda') !== 'true') return;
	    var src = '//cdn.bootcss.com/eruda/1.4.3/eruda.min.js';
	    document.write('<scr' + 'ipt src="' + src + '"></scr' + 'ipt>');
	    document.write('<scr' + 'ipt>eruda.init();</scr' + 'ipt>');
	})();
```

		这段代码的意思是如果URL中有参数eruda=true或者sessionStorage中eruda的值为true才加载Eruda
		
		这样的好处是，我们需要调试的时候可以在网页URL后面加个参数即可，不需要调试的它不会加载
		
		然而，这在开发阶段可以这样做比较好，但是在线上环境可能要加URL参数比较麻烦
		
		于是我想到了在页面中点击某个元素10次再加载Eruda，点击10次或者更多次，然后在sessionStorage中写入eruda=true
		
		然后刷新当前页。相反，再点击10次关闭Eruda。用这样比较隐藏的方式开启或关闭Eruda
		
		这样线上环境也可以自由开启或关闭Eruda了

> 例子：假如有这样的一个页面，里有一个标题文字

		<h2>——规则详情——</h2>
		<div>
		.....
		</div>
		那么我们可以在h2标签上绑定一个click事件，加入方法名叫showEruda

```javascript
	<h2 onclick="showEruda">——规则详情——</h2>
	<div>
	.....
	</div>
	<script>
	var count = 0;
	function showEruda () {
	    if (count >= 10) {    
	        var eruda = sessionStorage.getItem('eruda');
	        if (!eruda || eruda === 'false'){
	            sessionStorage.setItem('eruda', 'true')
	        } else {
	            sessionStorage.setItem('eruda', 'false')
	        }
	        location.reload()
	    }
	    count++
	}
	</script>
```

[原文链接地址，请戳我](https://blog.dunizb.com/2017/10/16/erdua/)

## -webkit-overflow-scrolling: touch

		在ios设备中，利用 overflow 来模拟滚动会出现卡顿的情况
		
		可以通过设置 -webkit-overflow-scrolling: touch; 来解决
		
		原因是设置后ios会为其创建一个 UIScrollView ，利用硬件来加速渲染
